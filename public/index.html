<html>
	<head>
		<title>make stuff happen</title>
		<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<style type="text/css">
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		#info {
			position: absolute;
			top: 30px; left: 150px; width: 800px;
			color: #000000;
			padding: 5px;
			font-family: Monospace;
			font-size: 13px;
			text-align: left;
			z-index:100;
		}
		</style>
		<script type="text/javascript" src="Three.js"></script>
		<script type="text/javascript" src="Detector.js"></script>
		<script type="text/javascript" src="RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="Stats.js"></script>
		<script type="text/javascript">
			var container
			  , stats
			  , camera
              , cameraTarget
			  , scene
              , projector
			  , renderer
			  , particles
			  , material
              , colors = []
              , mouse2D
			  , z = 500
              , ay = 0
              , ax = Math.PI/4
              , spinRadius = 300;

            var keys = {
                left: false,
                right: false,
                up: false,
                down: false
            };

			function init() {
				if (!Detector.webgl) {
					Detector.addGetWebGLMessage();
					return;
				}
				container = document.createElement('div');
				document.body.appendChild(container);
				camera = new THREE.CombinedCamera(window.innerWidth, window.innerHeight, 45, 1, 10000, -2000, 10000);
				camera.position.z = 1400;
                cameraTarget = new THREE.Vector3(0, 0, 0);
				scene = new THREE.Scene();
				//scene.fog = new THREE.FogExp2(0x000000, 0.0009);
                projector = new THREE.Projector();
				var geometry = new THREE.Geometry();
                // geometry.colors = colors;
				for (var i = 0, l = 10000; i < l; ++i) {
					geometry.vertices.push(new THREE.Vertex(new THREE.Vector3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY)));
				}
				material = new THREE.ParticleBasicMaterial({size: 64, map: THREE.ImageUtils.loadTexture('particle.png', THREE.UVMapping), vertexColors: false});
				material.color.setHSV(1.0, 0.2, 0.8);
				particles = new THREE.ParticleSystem(geometry, material);
				particles.dynamic = true;
				particles.sortParticles = true;
				particles.updateMatrix();
				scene.add(particles);
                var plane = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000, 20, 20), new THREE.MeshBasicMaterial({color: 0x555555, wireframe: true}));
                plane.rotation.x = -Math.PI/2;
                scene.add(plane); 
				var light = new THREE.DirectionalLight(0xffffff);
				light.position.x = 0;
				light.position.y = 0;
				light.position.z = 1;
				scene.add(light);
				renderer = new THREE.WebGLRenderer({ clearAlpha: 1, antialias: true });
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild(stats.domElement);
                mouse2D = new THREE.Vector3(0, 10000, 0.5);
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				//document.addEventListener('touchstart', onDocumentTouchStart, false);
				//document.addEventListener('touchmove', onDocumentTouchMove, false);
				//document.addEventListener('mousewheel', onDocumentMouseWheel, false);
                document.addEventListener('keydown', onKeyDown, false);
                document.addEventListener('keyup', onKeyUp, false);
				window.addEventListener('resize', onWindowResize, false);
				animate();
			}
			
			var roundRobin = 0;
			
			function onDocumentMouseMove(event) {
                mouse2D.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse2D.y = -(event.clientY / window.innerHeight) * 2 + 1;
                var ray = projector.pickingRay(mouse2D.clone(), camera);
                var intersects = ray.intersectScene(scene);
                if (intersects.length > 0) {
                    var intersector = getRealIntersector(intersects);
                    if (intersector) {
                        var i = intersector[0];
                        var v = particles.geometry.vertices[roundRobin];
                        roundRobin += 1;
                        v.position.x = i.point.x;
                        v.position.y = i.point.y;
                        v.position.z = i.point.z;
                        particles.geometry.__dirtyVertices = true;
                        particles.geometry.__dirtyColors = true;
                    }
                }
			}

            function onKeyDown(event) {
                if (event.which == 39) keys.right = true;
                else if (event.which == 37) keys.left = true;
                else if (event.which == 40) keys.down = true;
                else if (event.which == 38) keys.up = true;
            }

            function onKeyUp(event) {
                if (event.which == 39) keys.right = false;
                else if (event.which == 37) keys.left = false;
                else if (event.which == 40) keys.down = false;
                else if (event.which == 38) keys.up = false;
            }

			function onWindowResize(event) {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function animate() {
				requestAnimationFrame(animate);
				render();
				stats.update();
			}

            function getRealIntersector(intersects) {
                for(i = 0; i < intersects.length; i++) {
                    var intersector = intersects[i];
                    return intersects;
                    /*if (intersector.object != rollOverMesh) {
                        return intersector;
                    }*/
                }
                return null;
            }

			function render() {
				var time = new Date().getTime() * 0.00005;
                if (keys.up == true) ax += .1;
                else if (keys.down == true) ax -= .1;
                if (keys.right == true) ay += .1;
                else if (keys.left == true) ay -= .1;
                var radius = Math.sin(ax) * spinRadius;
				camera.position.x += (Math.sin(ay) * radius - camera.position.x) * 0.05;
				camera.position.z += (Math.cos(ay) * radius - camera.position.z) * 0.05;
				camera.position.y += (Math.cos(ax) * spinRadius - camera.position.y) * 0.05;
                camera.lookAt(cameraTarget);
				renderer.render(scene, camera);
			}
		</script>
	</head>
	<body onload="init();">
		<div id="info"></div>
	</body>
</html>
